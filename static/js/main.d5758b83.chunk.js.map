{"version":3,"sources":["components/Tile.js","components/Unit.js","components/Defeated.js","components/History.js","components/Board.js","App.js","serviceWorker.js","index.js"],"names":["Tile","props","unSelect","move","e","type","tileState","potentialPath","step","select","preventDefault","potentialKill","className","onClick","onContextMenu","children","isFilled","Unit","this","name","alignment","Component","Defeated","renderUnits","array","map","unit","i","length","key","uuid","nextProps","black","white","Slide","direction","in","mountOnEnter","unmountOnExit","timeout","History","history","List","id","subheader","ListSubheader","Typography","variant","gutterBottom","player","item","Grow","ListItem","divider","ListItemText","primary","React","Board","newGame","window","location","reload","updateStats","tile","kill","occupiedBy","setState","curState","defeatedBlack","state","defeatedWhite","hasWon","endTurn","blacksTurn","board","row","isActive","build_Bishop_Options_Array","tileToSelect","x","coordinatesNumerical","y","tilesToHighlight","push","markedBy","build_Rook_Options_Array","updateBoard","j","response","z","selectKing","checkBounds","selectQueen","selectBishop","selectKnight","selectRook","selectPawn","highlighted","getUnit","from","to","coordinates","console","log","tempObj","createUnit","undefined","initBoard","TILE_X_AXIS","firstTileInCol","subArr","TILE_Y_AXIS","tileObj","renderBoard","Zoom","col","Grid","container","spacing","justify","xs","lg","Button","color","App","Boolean","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.d5758b83.chunk.js","sourcesContent":["import React from 'react';\r\nimport './Tile.css'\r\n\r\n\r\nconst Tile = (props) => {\r\n\r\n    const select = () => {\r\n        props.select(props.tileState)\r\n    }\r\n\r\n    const unSelect = () => {\r\n            props.unSelect();\r\n    }\r\n\r\n    const step = () => {\r\n        props.step(props.tileState)\r\n    }\r\n\r\n    // Main move function which consists of the select, step and unselect functions passed from the main board component and effectively\r\n    // make the controls for the game.\r\n    const move = (e) => {\r\n        if (e.type === 'click') {\r\n            // If a tile is highlighted (Selected by the player), make the actual movement\r\n            if(props.tileState.potentialPath === true){\r\n                step();\r\n            }\r\n            // If not then show the player the options for the unit they click\r\n            else if(props.tileState.potentialPath === false){\r\n            unSelect()\r\n            select()\r\n            }\r\n            // Cancel the whole thing if mouse right click is triggered\r\n          } else if (e.type === 'contextmenu'){\r\n            e.preventDefault();\r\n            unSelect()\r\n          }\r\n    }\r\n    \r\n    // Conditional tile rendering\r\n    if(props.tileState.potentialKill === true && props.tileState.potentialPath === true){\r\n        return <td className=\"board-tile-canKill\" onClick={move} onContextMenu={move}>{props.children}</td>\r\n    }\r\n    else if(props.tileState.potentialPath === true){\r\n        return <td className=\"board-tile-selected\" onClick={move} onContextMenu={move}>{props.children}</td>\r\n    }\r\n    else if(props.isFilled === true){\r\n        return <td className=\"board-tile-filled\" onClick={move} onContextMenu={move}>{props.children}</td>\r\n    }\r\n    else if (props.isFilled === false){\r\n        return <td className=\"board-tile-empty\" onClick={move} onContextMenu={move}>{props.children}</td>\r\n    }\r\n    \r\n    // Shouldn't be reachable\r\n    else{\r\n       return <td className=\"board-tile-empty\" onClick={move} onContextMenu={move}>err(tile)</td>\r\n    }\r\n    \r\n    \r\n}\r\n\r\n\r\nexport default Tile;","import React, { Component } from \"react\";\r\nimport \"./Unit.css\";\r\n\r\nclass Unit extends Component {\r\n\r\n  render() {\r\n    return (\r\n      <i\r\n        className={`fas fa-chess-${this.props.name} ${this.props.alignment}`}\r\n      ></i>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Unit;\r\n","import React, { Component } from \"react\";\r\nimport Unit from \"./Unit\";\r\nimport uuid from \"react-uuid\";\r\nimport \"./Defeated.css\";\r\n\r\nimport Slide from \"@material-ui/core/Slide\";\r\n\r\nexport default class Defeated extends Component {\r\n  // To prevent needless re-rendering when props don't change\r\n  shouldComponentUpdate(nextProps) {\r\n    if (\r\n      this.props.black === nextProps.black &&\r\n      this.props.white === nextProps.white\r\n    ) {\r\n      return false;\r\n    } else return true;\r\n  }\r\n\r\n  // Helper function to for conditional animation rendering, will animate only the last item added to the array so that the whole\r\n  // array doesn't animate at once\r\n\r\n  renderUnits = array => {\r\n    return array.map((unit, i) => {\r\n      if (i === array.length - 1) {\r\n        return (\r\n          <div className=\"unit-spacing bounce-in-fwd\" key={uuid()}>\r\n            <Unit name={unit.name} alignment={unit.alignment} key={uuid()} />\r\n          </div>\r\n        );\r\n      } else {\r\n        return (\r\n          <div className=\"unit-spacing\" key={uuid()}>\r\n            <Unit name={unit.name} alignment={unit.alignment} key={uuid()} />\r\n          </div>\r\n        );\r\n      }\r\n    });\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <Slide\r\n        direction=\"right\"\r\n        in={true}\r\n        mountOnEnter\r\n        unmountOnExit\r\n        timeout={1500}\r\n      >\r\n        <div className=\"component-main-frame\">\r\n          {this.renderUnits(this.props.black)}\r\n          <br />\r\n          {this.renderUnits(this.props.white)}\r\n        </div>\r\n      </Slide>\r\n    );\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport List from \"@material-ui/core/List\";\r\nimport ListItem from \"@material-ui/core/ListItem\";\r\nimport ListItemText from \"@material-ui/core/ListItemText\";\r\nimport ListSubheader from \"@material-ui/core/ListSubheader\";\r\nimport Typography from \"@material-ui/core/Typography\";\r\nimport Slide from \"@material-ui/core/Slide\";\r\nimport Grow from \"@material-ui/core/Grow\";\r\n\r\nimport \"./History.css\";\r\n\r\nimport uuid from \"react-uuid\";\r\n\r\nexport default class History extends React.Component {\r\n  // To stop needless re-rendering if props don't change\r\n  shouldComponentUpdate(nextProps) {\r\n    if (this.props.history === nextProps.history) return false;\r\n    else return true;\r\n  }\r\n\r\n  render() {\r\n    // let classes = useStyles();\r\n\r\n    // Renders an animated scrollable list that displays the turn history passed from the main board component\r\n    return (\r\n      <Slide\r\n        direction=\"left\"\r\n        in={true}\r\n        mountOnEnter\r\n        unmountOnExit\r\n        timeout={1500}\r\n      >\r\n        <List id=\"list-main-frame\" subheader={<li />}>\r\n          <li>\r\n            <ul key={uuid()}>\r\n              <ListSubheader className=\"list-subheader\">\r\n                <Typography\r\n                  variant=\"h5\"\r\n                  gutterBottom\r\n                >{`${this.props.player}'s Turn`}</Typography>\r\n              </ListSubheader>\r\n              {this.props.history.map((item, i) => {\r\n                // If statemen  ts so that the whole array doesn't get animated everytime the props update\r\n\r\n                if (i === 0) {\r\n                  return (\r\n                    <Grow in={true} timeout={1000} key={uuid()}>\r\n                      <ListItem\r\n                        key={uuid()}\r\n                        className=\"list-item\"\r\n                        divider={true}\r\n                      >\r\n                        <ListItemText primary={`${item}`} className=\"primary\" />\r\n                      </ListItem>\r\n                    </Grow>\r\n                  );\r\n                } else {\r\n                  return (\r\n                    <ListItem key={uuid()} className=\"list-item\" divider={true}>\r\n                      <ListItemText primary={`${item}`} className=\"primary\" />\r\n                    </ListItem>\r\n                  );\r\n                }\r\n              })}\r\n            </ul>\r\n          </li>\r\n        </List>\r\n      </Slide>\r\n    );\r\n  }\r\n}\r\n","import React, { Component } from \"react\";\r\nimport Tile from \"./Tile\";\r\nimport uuid from \"react-uuid\";\r\nimport \"./Board.css\";\r\nimport Unit from \"./Unit\";\r\nimport Defeated from \"./Defeated\";\r\nimport History from \"./History\";\r\n\r\nimport Grid from \"@material-ui/core/Grid\";\r\nimport Button from \"@material-ui/core/Button\";\r\nimport Zoom from \"@material-ui/core/Zoom\";\r\n\r\n\r\nclass Board extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      board: [],\r\n      // These are sent to the Defeated child component for display\r\n      defeatedWhite: [],\r\n      defeatedBlack: [],\r\n      //\r\n      // Sent to the History child component for display\r\n      history: [],\r\n      // Tracks whether it's the black player's turn. All properties except for board can be organized more elegantly\r\n      // By using playerWhite and playerBlack objects with their respective properties. I decided against this to avoid more\r\n      // Un-needed nesting which React discourages. If this was done in Java/C# or similar that would be a better approach.\r\n      blacksTurn: null,\r\n      hasWon: null\r\n    };\r\n  }\r\n\r\n  // Onclick for the 'New Game' Button\r\n  newGame = () => {\r\n    // Generally, forcing a hard refresh when dealing with Single-page applications is in most cases not a good solution.\r\n    // In this specific case I opted for this approach since no data is being stored and there is no danger of unpredictable\r\n    // side effects\r\n\r\n    window.location.reload();\r\n  };\r\n\r\n  // Updates the defeated unit logs and checks whether win conditions have been met\r\n  updateStats = (tile, kill) => {\r\n    if (tile.occupiedBy.alignment === \"black\") {\r\n      this.setState(curState => ({\r\n        defeatedBlack: [...curState.defeatedBlack, tile.occupiedBy]\r\n      }));\r\n\r\n      // Check for win conditions, whether the killed unit is a king or if all enemy units are killed\r\n\r\n      // Kill entry in history log\r\n      kill = `Black player's ${tile.occupiedBy.name} was killed!`;\r\n\r\n      if (\r\n        tile.occupiedBy.name === \"king\" ||\r\n        this.state.defeatedWhite.length === 16\r\n      ) {\r\n        this.setState({\r\n          hasWon: \"white\"\r\n        });\r\n      }\r\n    } else if (tile.occupiedBy.alignment === \"white\") {\r\n      this.setState(curState => ({\r\n        defeatedWhite: [...curState.defeatedWhite, tile.occupiedBy]\r\n      }));\r\n\r\n      // Kill entry in history log\r\n      kill = `White player's ${tile.occupiedBy.name} was killed!`;\r\n\r\n      if (\r\n        tile.occupiedBy.name === \"king\" ||\r\n        this.state.defeatedBlack.length === 16\r\n      ) {\r\n        this.setState({\r\n          hasWon: \"black\"\r\n        });\r\n      }\r\n    }\r\n\r\n    return kill;\r\n  };\r\n\r\n  // Switches the players turn and updates isActive accordingly on individual pieces\r\n  endTurn = () => {\r\n    // End turn and pass it to the other player\r\n    this.setState(curState => ({\r\n      blacksTurn: !curState.blacksTurn\r\n    }));\r\n\r\n    // Switches the active pieces on the board according the the current player's turn\r\n    this.setState(({ board }) => ({\r\n      board: board.map(row => {\r\n        let newRow = row.map(tile => {\r\n          if (this.state.blacksTurn === false) {\r\n            if (tile.occupiedBy !== null) {\r\n              if (tile.occupiedBy !== null) {\r\n                if (tile.occupiedBy.alignment === \"white\") {\r\n                  return { ...tile, isActive: false };\r\n                } else if (tile.occupiedBy.alignment === \"black\") {\r\n                  return { ...tile, isActive: true };\r\n                }\r\n              }\r\n            }\r\n          } else if (this.state.blacksTurn === true) {\r\n            if (tile.occupiedBy !== null) {\r\n              if (tile.occupiedBy.alignment === \"white\") {\r\n                return { ...tile, isActive: true };\r\n              } else if (tile.occupiedBy.alignment === \"black\") {\r\n                return { ...tile, isActive: false };\r\n              }\r\n            }\r\n          }\r\n\r\n          return tile;\r\n        });\r\n\r\n        // warning said wasn't returning in all cases, so I added this\r\n        return newRow;\r\n      })\r\n    }));\r\n    //\r\n  };\r\n\r\n  // Bishop and Rook have their own movement option builder functions because this is reused on the Queen unit\r\n  // to avoid duplicate code (Queen movement is a combination of Bishop and Rook).\r\n  build_Bishop_Options_Array = tileToSelect => {\r\n    // Extract x, y axis for readability\r\n    const x = tileToSelect.coordinatesNumerical[0];\r\n    const y = tileToSelect.coordinatesNumerical[1];\r\n\r\n    const tilesToHighlight = [];\r\n\r\n    //  forEach shouldn't be used since we need to check for collision and return in a case of collision will not end a forEach loop\r\n    //  These loops iterate in every direction the rook can move in including collision detection with other units.\r\n    //  Each tile that qualifies is then pushed into the tilesToHighlight array that is then merged into the board to show the options\r\n    //  to the player.\r\n\r\n    // TOP RIGHT\r\n    let i = 1;\r\n    while (x - i < 8 && y + i < 8 && x - i >= 0 && y + i >= 0) {\r\n      // COLLISION CHECK\r\n      if (this.state.board[x - i][y + i].occupiedBy !== null && i !== x) {\r\n        if (\r\n          this.state.board[x - i][y + i].occupiedBy.alignment ===\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          break;\r\n        }\r\n\r\n        // This deals with an edge case of jumping over a piece for a kill move, the push into array makes the piece inclusive\r\n        // rather than non-inclusive in the collision check.\r\n        if (\r\n          this.state.board[x - i][y + i].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          tilesToHighlight.push({\r\n            ...this.state.board[x - i][y + i],\r\n            potentialPath: true,\r\n            potentialKill: true,\r\n            markedBy: this.state.board[x][y].coordinatesNumerical\r\n          });\r\n          break;\r\n        }\r\n      }\r\n      //\r\n\r\n      if (this.state.board[x - i][y + i].occupiedBy === null) {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x - i][y + i],\r\n          potentialPath: true,\r\n          markedBy: this.state.board[x][y].coordinatesNumerical\r\n        });\r\n      } else if (\r\n        this.state.board[x - i][y + i].occupiedBy !== null &&\r\n        this.state.board[x - i][y + i].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n      ) {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x - i][y + i],\r\n          potentialPath: true,\r\n          potentialKill: true,\r\n          markedBy: this.state.board[x][y].coordinatesNumerical\r\n        });\r\n      }\r\n\r\n      i++;\r\n    }\r\n\r\n    // TOP LEFT\r\n    i = 1;\r\n    while (x - i >= 0 && y - i >= 0 && x - i < 8 && y - i < 8) {\r\n      // COLLISION CHECK\r\n      if (this.state.board[x - i][y - i].occupiedBy !== null && i !== x) {\r\n        if (\r\n          this.state.board[x - i][y - i].occupiedBy.alignment ===\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          break;\r\n        }\r\n\r\n        // This deals with an edge case of jumping over a piece for a kill move, the push into array makes the piece inclusive\r\n        // rather than non-inclusive in the collision check.\r\n        if (\r\n          this.state.board[x - i][y - i].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          tilesToHighlight.push({\r\n            ...this.state.board[x - i][y - i],\r\n            potentialPath: true,\r\n            potentialKill: true,\r\n            markedBy: this.state.board[x][y].coordinatesNumerical\r\n          });\r\n          break;\r\n        }\r\n      }\r\n      //\r\n\r\n      if (this.state.board[x - i][y - i].occupiedBy === null) {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x - i][y - i],\r\n          potentialPath: true,\r\n          markedBy: this.state.board[x][y].coordinatesNumerical\r\n        });\r\n      } else if (\r\n        this.state.board[x - i][y - i].occupiedBy !== null &&\r\n        this.state.board[x - i][y - i].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n      ) {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x - i][y - i],\r\n          potentialPath: true,\r\n          potentialKill: true,\r\n          markedBy: this.state.board[x][y].coordinatesNumerical\r\n        });\r\n      }\r\n\r\n      i++;\r\n    }\r\n\r\n    // BOTTOM LEFT\r\n    i = 1;\r\n    while (x + i < 8 && y - i < 8 && x + i >= 0 && y - i >= 0) {\r\n      // COLLISION CHECK\r\n      if (this.state.board[x + i][y - i].occupiedBy !== null && i !== x) {\r\n        if (\r\n          this.state.board[x + i][y - i].occupiedBy.alignment ===\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          break;\r\n        }\r\n\r\n        // This deals with an edge case of jumping over a piece for a kill move, the push into array makes the piece inclusive\r\n        // rather than non-inclusive in the collision check.\r\n        if (\r\n          this.state.board[x + i][y - i].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          tilesToHighlight.push({\r\n            ...this.state.board[x + i][y - i],\r\n            potentialPath: true,\r\n            potentialKill: true,\r\n            markedBy: this.state.board[x][y].coordinatesNumerical\r\n          });\r\n          break;\r\n        }\r\n      }\r\n      //\r\n\r\n      if (this.state.board[x + i][y - i].occupiedBy === null) {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x + i][y - i],\r\n          potentialPath: true,\r\n          markedBy: this.state.board[x][y].coordinatesNumerical\r\n        });\r\n      } else if (\r\n        this.state.board[x + i][y - i].occupiedBy !== null &&\r\n        this.state.board[x + i][y - i].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n      ) {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x + i][y - i],\r\n          potentialPath: true,\r\n          potentialKill: true,\r\n          markedBy: this.state.board[x][y].coordinatesNumerical\r\n        });\r\n      }\r\n\r\n      i++;\r\n    }\r\n\r\n    // BOTTOM RIGHT\r\n    i = 1;\r\n    while (x + i < 8 && y + i < 8 && x + i >= 0 && y + i >= 0) {\r\n      // COLLISION CHECK\r\n      if (this.state.board[x + i][y + i].occupiedBy !== null && i !== x) {\r\n        if (\r\n          this.state.board[x + i][y + i].occupiedBy.alignment ===\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          break;\r\n        }\r\n\r\n        // This deals with an edge case of jumping over a piece for a kill move, the push into array makes the piece inclusive\r\n        // rather than non-inclusive in the collision check.\r\n        if (\r\n          this.state.board[x + i][y + i].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          tilesToHighlight.push({\r\n            ...this.state.board[x + i][y + i],\r\n            potentialPath: true,\r\n            potentialKill: true,\r\n            markedBy: this.state.board[x][y].coordinatesNumerical\r\n          });\r\n          break;\r\n        }\r\n      }\r\n      //\r\n\r\n      if (this.state.board[x + i][y + i].occupiedBy === null) {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x + i][y + i],\r\n          potentialPath: true,\r\n          markedBy: this.state.board[x][y].coordinatesNumerical\r\n        });\r\n      } else if (\r\n        this.state.board[x + i][y + i].occupiedBy !== null &&\r\n        this.state.board[x + i][y + i].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n      ) {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x + i][y + i],\r\n          potentialPath: true,\r\n          potentialKill: true,\r\n          markedBy: this.state.board[x][y].coordinatesNumerical\r\n        });\r\n      }\r\n\r\n      i++;\r\n    }\r\n\r\n    return tilesToHighlight;\r\n  };\r\n\r\n  build_Rook_Options_Array = tileToSelect => {\r\n    // Extract x, y axis for readability\r\n    const x = tileToSelect.coordinatesNumerical[0];\r\n    const y = tileToSelect.coordinatesNumerical[1];\r\n\r\n    const tilesToHighlight = [];\r\n\r\n    //  forEach shouldn't be used since we need to check for collision and return in a case of collision will not end a forEach loop\r\n    //  These loops iterate in every direction the rook can move in including collision detection with other units.\r\n    //  Each tile that qualifies is then pushed into the tilesToHighlight array that is then merged into the board to show the options\r\n    //  to the player.\r\n\r\n    // UP\r\n    for (let i = x; i >= 0; i--) {\r\n      // COLLISION CHECK\r\n      if (this.state.board[i][y].occupiedBy !== null && i !== x) {\r\n        if (\r\n          this.state.board[i][y].occupiedBy.alignment ===\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          break;\r\n        }\r\n\r\n        // This deals with an edge case of jumping over a piece for a kill move, the push into array makes the piece inclusive\r\n        // rather than non-inclusive in the collision check.\r\n        if (\r\n          this.state.board[i][y].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          tilesToHighlight.push({\r\n            ...this.state.board[i][y],\r\n            potentialPath: true,\r\n            potentialKill: true,\r\n            markedBy: this.state.board[x][y].coordinatesNumerical\r\n          });\r\n          break;\r\n        }\r\n      }\r\n      //\r\n\r\n      if (this.state.board[i][y].occupiedBy === null) {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[i][y],\r\n          potentialPath: true,\r\n          markedBy: this.state.board[x][y].coordinatesNumerical\r\n        });\r\n      } else if (\r\n        this.state.board[i][y].occupiedBy !== null &&\r\n        this.state.board[i][y].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n      ) {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[i][y],\r\n          potentialPath: true,\r\n          potentialKill: true,\r\n          markedBy: this.state.board[x][y].coordinatesNumerical\r\n        });\r\n      }\r\n    }\r\n\r\n    // DOWN\r\n    for (let i = x; i < 8; i++) {\r\n      // COLLISION CHECK\r\n      if (this.state.board[i][y].occupiedBy !== null && i !== x) {\r\n        if (\r\n          this.state.board[i][y].occupiedBy.alignment ===\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          break;\r\n        }\r\n\r\n        // This deals with an edge case of jumping over a piece for a kill move, the push into array makes the piece inclusive\r\n        // rather than non-inclusive in the collision check.\r\n        if (\r\n          this.state.board[i][y].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          tilesToHighlight.push({\r\n            ...this.state.board[i][y],\r\n            potentialPath: true,\r\n            potentialKill: true,\r\n            markedBy: this.state.board[x][y].coordinatesNumerical\r\n          });\r\n          break;\r\n        }\r\n      }\r\n      //\r\n\r\n      if (this.state.board[i][y].occupiedBy === null) {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[i][y],\r\n          potentialPath: true,\r\n          markedBy: this.state.board[x][y].coordinatesNumerical\r\n        });\r\n      } else if (\r\n        this.state.board[i][y].occupiedBy !== null &&\r\n        this.state.board[i][y].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n      ) {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[i][y],\r\n          potentialPath: true,\r\n          potentialKill: true,\r\n          markedBy: this.state.board[x][y].coordinatesNumerical\r\n        });\r\n      }\r\n    }\r\n\r\n    // RIGHT\r\n    for (let i = y; i < 8; i++) {\r\n      // COLLISION CHECK\r\n      if (this.state.board[x][i].occupiedBy !== null && i !== y) {\r\n        if (\r\n          this.state.board[x][i].occupiedBy.alignment ===\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          break;\r\n        }\r\n\r\n        // This deals with an edge case of jumping over a piece for a kill move, the push into array makes the piece inclusive\r\n        // rather than non-inclusive in the collision check.\r\n        if (\r\n          this.state.board[x][i].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          tilesToHighlight.push({\r\n            ...this.state.board[x][i],\r\n            potentialPath: true,\r\n            potentialKill: true,\r\n            markedBy: this.state.board[x][y].coordinatesNumerical\r\n          });\r\n          break;\r\n        }\r\n      }\r\n      //\r\n\r\n      if (this.state.board[x][i].occupiedBy === null) {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x][i],\r\n          potentialPath: true,\r\n          markedBy: this.state.board[x][y].coordinatesNumerical\r\n        });\r\n      } else if (\r\n        this.state.board[x][i].occupiedBy !== null &&\r\n        this.state.board[x][i].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n      ) {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x][i],\r\n          potentialPath: true,\r\n          potentialKill: true,\r\n          markedBy: this.state.board[x][y].coordinatesNumerical\r\n        });\r\n      }\r\n    }\r\n\r\n    // LEFT\r\n    for (let i = y; i >= 0; i--) {\r\n      // COLLISION CHECK\r\n      if (this.state.board[x][i].occupiedBy !== null && i !== y) {\r\n        if (\r\n          this.state.board[x][i].occupiedBy.alignment ===\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          break;\r\n        }\r\n\r\n        // This deals with an edge case of jumping over a piece for a kill move, the push into array makes the piece inclusive\r\n        // rather than non-inclusive in the collision check.\r\n        if (\r\n          this.state.board[x][i].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          tilesToHighlight.push({\r\n            ...this.state.board[x][i],\r\n            potentialPath: true,\r\n            potentialKill: true,\r\n            markedBy: this.state.board[x][y].coordinatesNumerical\r\n          });\r\n          break;\r\n        }\r\n      }\r\n      //\r\n\r\n      if (this.state.board[x][i].occupiedBy === null) {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x][i],\r\n          potentialPath: true,\r\n          markedBy: this.state.board[x][y].coordinatesNumerical\r\n        });\r\n      } else if (\r\n        this.state.board[x][i].occupiedBy !== null &&\r\n        this.state.board[x][i].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n      ) {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x][i],\r\n          potentialPath: true,\r\n          potentialKill: true,\r\n          markedBy: this.state.board[x][y].coordinatesNumerical\r\n        });\r\n      }\r\n    }\r\n\r\n    return tilesToHighlight;\r\n  };\r\n  //\r\n\r\n  // Takes a bound validated array of potential movement paths/kills and merges into the board to highlight a unit's options\r\n  updateBoard = tilesToHighlight => {\r\n    // To update state need to map over the whole board\r\n    this.setState(({ board }) => ({\r\n      board: board.map((row, i) => {\r\n        let newRow = row.map((tile, j) => {\r\n          let response = null;\r\n\r\n          for (let z = 0; z < tilesToHighlight.length; z++) {\r\n            if (tilesToHighlight[z].potentialKill === true) {\r\n              // Check for matching coords, a kill move and a tile that is not empty\r\n              if (\r\n                i === tilesToHighlight[z].coordinatesNumerical[0] &&\r\n                j === tilesToHighlight[z].coordinatesNumerical[1] &&\r\n                tilesToHighlight[z] !== null\r\n              ) {\r\n                response = { ...tilesToHighlight[z] };\r\n              }\r\n            }\r\n            // Else if that's not a kill move check that the tile IS empty\r\n            else if (tilesToHighlight[z].potentialKill === false) {\r\n              if (\r\n                i === tilesToHighlight[z].coordinatesNumerical[0] &&\r\n                j === tilesToHighlight[z].coordinatesNumerical[1] &&\r\n                tilesToHighlight[z].occupiedBy === null\r\n              ) {\r\n                response = { ...tilesToHighlight[z] };\r\n              }\r\n            }\r\n          }\r\n\r\n          if (response !== null) {\r\n            return response;\r\n          } else {\r\n            return tile;\r\n          }\r\n        });\r\n        // warning said I wasn't returning in all cases, so I added this\r\n        return newRow;\r\n      })\r\n    }));\r\n  };\r\n\r\n  selectKing = tileToSelect => {\r\n    // Extract x, y axis for readability\r\n    const x = tileToSelect.coordinatesNumerical[0];\r\n    const y = tileToSelect.coordinatesNumerical[1];\r\n\r\n    // check alignment\r\n\r\n    // Creates an empty array and checks based on the Unit's position what tiles to highlight, makes a conditional check with a helper\r\n    // function to see that the tiles are inside the board to prevent arrayOutOfBounds exception, the ones that pass the check\r\n    // are pushed into the array that is later merged into the state. Each highlighted tile receives the coordinates of the tile\r\n    // that highlighted it so later on it knows from where to remove the tile and override onto themselves.\r\n\r\n    // NOTE: THIS ARRAY SHOULD BE VALIDATED FOR BOUNDS BEFORE IT GOES INTO MAP\r\n    const tilesToHighlight = [];\r\n\r\n    // Check if this is the first turn (Initial movement) of the pawn, where it can move two tiles instead of one\r\n\r\n    // The array building is done with if statements since there are a maximum of 8 options. Each statement will check whether the\r\n    // destination tile is within the bounds of the board, whether the destination is a movement/kill and will build the tile\r\n    // object appropriately. Although this section can be refactored to use loops and be syntactically shorter, it will impair\r\n    // readability and make the code more difficult to understand.\r\n\r\n    // TOP\r\n    if (this.checkBounds(x - 1, y)) {\r\n      if (this.state.board[x - 1][y].occupiedBy !== null) {\r\n        if (\r\n          this.state.board[x - 1][y].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          tilesToHighlight.push({\r\n            ...this.state.board[x - 1][y],\r\n            markedBy: this.state.board[x][y].coordinatesNumerical,\r\n            potentialPath: true,\r\n            potentialKill: true\r\n          });\r\n        }\r\n      } else {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x - 1][y],\r\n          markedBy: this.state.board[x][y].coordinatesNumerical,\r\n          potentialPath: true\r\n        });\r\n      }\r\n    }\r\n\r\n    // TOP RIGHT\r\n    if (this.checkBounds(x - 1, y + 1)) {\r\n      if (this.state.board[x - 1][y + 1].occupiedBy !== null) {\r\n        if (\r\n          this.state.board[x - 1][y + 1].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          tilesToHighlight.push({\r\n            ...this.state.board[x - 1][y + 1],\r\n            markedBy: this.state.board[x][y].coordinatesNumerical,\r\n            potentialPath: true,\r\n            potentialKill: true\r\n          });\r\n        }\r\n      } else {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x - 1][y + 1],\r\n          markedBy: this.state.board[x][y].coordinatesNumerical,\r\n          potentialPath: true\r\n        });\r\n      }\r\n    }\r\n\r\n    // TOP LEFT\r\n    if (this.checkBounds(x - 1, y - 1)) {\r\n      if (this.state.board[x - 1][y - 1].occupiedBy !== null) {\r\n        if (\r\n          this.state.board[x - 1][y - 1].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          tilesToHighlight.push({\r\n            ...this.state.board[x - 1][y - 1],\r\n            markedBy: this.state.board[x][y].coordinatesNumerical,\r\n            potentialPath: true,\r\n            potentialKill: true\r\n          });\r\n        }\r\n      } else {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x - 1][y - 1],\r\n          markedBy: this.state.board[x][y].coordinatesNumerical,\r\n          potentialPath: true\r\n        });\r\n      }\r\n    }\r\n\r\n    // BOTTOM\r\n    if (this.checkBounds(x + 1, y)) {\r\n      if (this.state.board[x + 1][y].occupiedBy !== null) {\r\n        if (\r\n          this.state.board[x + 1][y].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          tilesToHighlight.push({\r\n            ...this.state.board[x + 1][y],\r\n            markedBy: this.state.board[x][y].coordinatesNumerical,\r\n            potentialPath: true,\r\n            potentialKill: true\r\n          });\r\n        }\r\n      } else {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x + 1][y],\r\n          markedBy: this.state.board[x][y].coordinatesNumerical,\r\n          potentialPath: true\r\n        });\r\n      }\r\n    }\r\n\r\n    // BOTTOM RIGHT\r\n    if (this.checkBounds(x + 1, y + 1)) {\r\n      if (this.state.board[x + 1][y + 1].occupiedBy !== null) {\r\n        if (\r\n          this.state.board[x + 1][y + 1].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          tilesToHighlight.push({\r\n            ...this.state.board[x + 1][y + 1],\r\n            markedBy: this.state.board[x][y].coordinatesNumerical,\r\n            potentialPath: true,\r\n            potentialKill: true\r\n          });\r\n        }\r\n      } else {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x + 1][y + 1],\r\n          markedBy: this.state.board[x][y].coordinatesNumerical,\r\n          potentialPath: true\r\n        });\r\n      }\r\n    }\r\n\r\n    // BOTTOM LEFT\r\n    if (this.checkBounds(x + 1, y - 1)) {\r\n      if (this.state.board[x + 1][y - 1].occupiedBy !== null) {\r\n        if (\r\n          this.state.board[x + 1][y - 1].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          tilesToHighlight.push({\r\n            ...this.state.board[x + 1][y - 1],\r\n            markedBy: this.state.board[x][y].coordinatesNumerical,\r\n            potentialPath: true,\r\n            potentialKill: true\r\n          });\r\n        }\r\n      } else {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x + 1][y - 1],\r\n          markedBy: this.state.board[x][y].coordinatesNumerical,\r\n          potentialPath: true\r\n        });\r\n      }\r\n    }\r\n\r\n    // LEFT\r\n    if (this.checkBounds(x, y - 1)) {\r\n      if (this.state.board[x][y - 1].occupiedBy !== null) {\r\n        if (\r\n          this.state.board[x][y - 1].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          tilesToHighlight.push({\r\n            ...this.state.board[x][y - 1],\r\n            markedBy: this.state.board[x][y].coordinatesNumerical,\r\n            potentialPath: true,\r\n            potentialKill: true\r\n          });\r\n        }\r\n      } else {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x][y - 1],\r\n          markedBy: this.state.board[x][y].coordinatesNumerical,\r\n          potentialPath: true\r\n        });\r\n      }\r\n    }\r\n\r\n    // RIGHT\r\n    if (this.checkBounds(x, y + 1)) {\r\n      if (this.state.board[x][y + 1].occupiedBy !== null) {\r\n        if (\r\n          this.state.board[x][y + 1].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          tilesToHighlight.push({\r\n            ...this.state.board[x][y + 1],\r\n            markedBy: this.state.board[x][y].coordinatesNumerical,\r\n            potentialPath: true,\r\n            potentialKill: true\r\n          });\r\n        }\r\n      } else {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x][y + 1],\r\n          markedBy: this.state.board[x][y].coordinatesNumerical,\r\n          potentialPath: true\r\n        });\r\n      }\r\n    }\r\n\r\n    this.updateBoard(tilesToHighlight);\r\n  };\r\n\r\n  selectQueen = tileToSelect => {\r\n    let tilesToHighlight = [\r\n      ...this.build_Bishop_Options_Array(tileToSelect),\r\n      ...this.build_Rook_Options_Array(tileToSelect)\r\n    ];\r\n\r\n    this.updateBoard(tilesToHighlight);\r\n  };\r\n\r\n  selectBishop = tileToSelect => {\r\n    let tilesToHighlight = this.build_Bishop_Options_Array(tileToSelect);\r\n\r\n    this.updateBoard(tilesToHighlight);\r\n  };\r\n\r\n  // Main Knight function, selects all the the movement options for the unit. Should receieve the knight tile as an argument\r\n  selectKnight = tileToSelect => {\r\n    // Extract x, y axis for readability\r\n    const x = tileToSelect.coordinatesNumerical[0];\r\n    const y = tileToSelect.coordinatesNumerical[1];\r\n\r\n    // check alignment\r\n\r\n    // Creates an empty array and checks based on the Unit's position what tiles to highlight, makes a conditional check with a helper\r\n    // function to see that the tiles are inside the board to prevent arrayOutOfBounds exception, the ones that pass the check\r\n    // are pushed into the array that is later merged into the state. Each highlighted tile receives the coordinates of the tile\r\n    // that highlighted it so later on it knows from where to remove the tile and override onto themselves.\r\n\r\n    // NOTE: THIS ARRAY SHOULD BE VALIDATED FOR BOUNDS BEFORE IT GOES INTO MAP\r\n    const tilesToHighlight = [];\r\n\r\n    // Check if this is the first turn (Initial movement) of the pawn, where it can move two tiles instead of one\r\n\r\n    // The array building is done with if statements since there are a maximum of 8 options. Each statement will check whether the\r\n    // destination tile is within the bounds of the board, whether the destination is a movement/kill and will build the tile\r\n    // object appropriately. Although this section can be refactored to use loops and be syntactically shorter, it will impair\r\n    // readability and make the code more difficult to understand.\r\n\r\n    // TOP RIGHT\r\n    if (this.checkBounds(x - 2, y + 1)) {\r\n      if (this.state.board[x - 2][y + 1].occupiedBy !== null) {\r\n        if (\r\n          this.state.board[x - 2][y + 1].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          tilesToHighlight.push({\r\n            ...this.state.board[x - 2][y + 1],\r\n            markedBy: this.state.board[x][y].coordinatesNumerical,\r\n            potentialPath: true,\r\n            potentialKill: true\r\n          });\r\n        }\r\n      } else {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x - 2][y + 1],\r\n          markedBy: this.state.board[x][y].coordinatesNumerical,\r\n          potentialPath: true\r\n        });\r\n      }\r\n    }\r\n\r\n    //\r\n    // TOP LEFT\r\n    if (this.checkBounds(x - 2, y - 1)) {\r\n      if (this.state.board[x - 2][y - 1].occupiedBy !== null) {\r\n        if (\r\n          this.state.board[x - 2][y - 1].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          tilesToHighlight.push({\r\n            ...this.state.board[x - 2][y - 1],\r\n            markedBy: this.state.board[x][y].coordinatesNumerical,\r\n            potentialPath: true,\r\n            potentialKill: true\r\n          });\r\n        }\r\n      } else {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x - 2][y - 1],\r\n          markedBy: this.state.board[x][y].coordinatesNumerical,\r\n          potentialPath: true\r\n        });\r\n      }\r\n    }\r\n\r\n    // RIGHT SIDE TOP\r\n    if (this.checkBounds(x - 1, y + 2)) {\r\n      if (this.state.board[x - 1][y + 2].occupiedBy !== null) {\r\n        if (\r\n          this.state.board[x - 1][y + 2].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          tilesToHighlight.push({\r\n            ...this.state.board[x - 1][y + 2],\r\n            markedBy: this.state.board[x][y].coordinatesNumerical,\r\n            potentialPath: true,\r\n            potentialKill: true\r\n          });\r\n        }\r\n      } else {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x - 1][y + 2],\r\n          markedBy: this.state.board[x][y].coordinatesNumerical,\r\n          potentialPath: true\r\n        });\r\n      }\r\n    }\r\n\r\n    // RIGHT SIDE LEFT\r\n    if (this.checkBounds(x - 1, y - 2)) {\r\n      if (this.state.board[x - 1][y - 2].occupiedBy !== null) {\r\n        if (\r\n          this.state.board[x - 1][y - 2].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          tilesToHighlight.push({\r\n            ...this.state.board[x - 1][y - 2],\r\n            markedBy: this.state.board[x][y].coordinatesNumerical,\r\n            potentialPath: true,\r\n            potentialKill: true\r\n          });\r\n        }\r\n      } else {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x - 1][y - 2],\r\n          markedBy: this.state.board[x][y].coordinatesNumerical,\r\n          potentialPath: true\r\n        });\r\n      }\r\n    }\r\n\r\n    // BOTTOM SIDE LEFT\r\n    if (this.checkBounds(x + 1, y - 2)) {\r\n      if (this.state.board[x + 1][y - 2].occupiedBy !== null) {\r\n        if (\r\n          this.state.board[x + 1][y - 2].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          tilesToHighlight.push({\r\n            ...this.state.board[x + 1][y - 2],\r\n            markedBy: this.state.board[x][y].coordinatesNumerical,\r\n            potentialPath: true,\r\n            potentialKill: true\r\n          });\r\n        }\r\n      } else {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x + 1][y - 2],\r\n          markedBy: this.state.board[x][y].coordinatesNumerical,\r\n          potentialPath: true\r\n        });\r\n      }\r\n    }\r\n\r\n    // BOTTOM SIDE RIGHT\r\n    if (this.checkBounds(x + 1, y + 2)) {\r\n      if (this.state.board[x + 1][y + 2].occupiedBy !== null) {\r\n        if (\r\n          this.state.board[x + 1][y + 2].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          tilesToHighlight.push({\r\n            ...this.state.board[x + 1][y + 2],\r\n            markedBy: this.state.board[x][y].coordinatesNumerical,\r\n            potentialPath: true,\r\n            potentialKill: true\r\n          });\r\n        }\r\n      } else {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x + 1][y + 2],\r\n          markedBy: this.state.board[x][y].coordinatesNumerical,\r\n          potentialPath: true\r\n        });\r\n      }\r\n    }\r\n\r\n    // BOTTOM LEFT\r\n    if (this.checkBounds(x + 2, y - 1)) {\r\n      if (this.state.board[x + 2][y - 1].occupiedBy !== null) {\r\n        if (\r\n          this.state.board[x + 2][y - 1].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          tilesToHighlight.push({\r\n            ...this.state.board[x + 2][y - 1],\r\n            markedBy: this.state.board[x][y].coordinatesNumerical,\r\n            potentialPath: true,\r\n            potentialKill: true\r\n          });\r\n        }\r\n      } else {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x + 2][y - 1],\r\n          markedBy: this.state.board[x][y].coordinatesNumerical,\r\n          potentialPath: true\r\n        });\r\n      }\r\n    }\r\n\r\n    // BOTTOM RIGHT\r\n    if (this.checkBounds(x + 2, y + 1)) {\r\n      if (this.state.board[x + 2][y + 1].occupiedBy !== null) {\r\n        if (\r\n          this.state.board[x + 2][y + 1].occupiedBy.alignment !==\r\n          this.state.board[x][y].occupiedBy.alignment\r\n        ) {\r\n          tilesToHighlight.push({\r\n            ...this.state.board[x + 2][y + 1],\r\n            markedBy: this.state.board[x][y].coordinatesNumerical,\r\n            potentialPath: true,\r\n            potentialKill: true\r\n          });\r\n        }\r\n      } else {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x + 2][y + 1],\r\n          markedBy: this.state.board[x][y].coordinatesNumerical,\r\n          potentialPath: true\r\n        });\r\n      }\r\n    }\r\n\r\n    this.updateBoard(tilesToHighlight);\r\n  };\r\n\r\n  // Main Rook function, selects all the the movement options for the unit. Should receieve the rook tile as an argument\r\n  selectRook = tileToSelect => {\r\n    let tilesToHighlight = this.build_Rook_Options_Array(tileToSelect);\r\n\r\n    // Merge movement options of the unit into the board state\r\n    this.updateBoard(tilesToHighlight);\r\n  };\r\n\r\n  // Main Pawn function, selects all the the movement options for the unit. Should receieve the pawn tile as an argument\r\n  selectPawn = tileToSelect => {\r\n    // Extract x, y axis for readability\r\n    const x = tileToSelect.coordinatesNumerical[0];\r\n    const y = tileToSelect.coordinatesNumerical[1];\r\n\r\n    // check alignment\r\n    if (tileToSelect.occupiedBy.alignment === \"white\") {\r\n      // Creates an empty array and checks based on the Unit's position what tiles to highlight, makes a conditional check with a helper\r\n      // function to see that the tiles are inside the board to prevent arrayOutOfBounds exception, the ones that pass the check\r\n      // are pushed into the array that is later merged into the state. Each highlighted tile receives the coordinates of the tile\r\n      // that highlighted it so later on it knows from where to remove the tile and override onto themselves.\r\n\r\n      // NOTE: THIS ARRAY SHOULD BE VALIDATED FOR BOUNDS BEFORE IT GOES INTO MAP\r\n      const tilesToHighlight = [];\r\n\r\n      // Check if this is the first turn (Initial movement) of the pawn, where it can move two tiles instead of one\r\n      if (x === 6) {\r\n        if (this.checkBounds(x - 2, y)) {\r\n          tilesToHighlight.push({\r\n            ...this.state.board[x - 2][y],\r\n            markedBy: this.state.board[x][y].coordinatesNumerical,\r\n            potentialPath: true\r\n          });\r\n        }\r\n      }\r\n      //\r\n\r\n      if (this.checkBounds(x - 1, y)) {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x - 1][y],\r\n          markedBy: this.state.board[x][y].coordinatesNumerical,\r\n          potentialPath: true\r\n        });\r\n      }\r\n\r\n      // This checks for potential kills of the unit, if the tile's not empty\r\n      if (\r\n        this.checkBounds(x - 1, y - 1) &&\r\n        this.state.board[x - 1][y - 1].occupiedBy !== null &&\r\n        this.state.board[x - 1][y - 1].occupiedBy.alignment !==\r\n          tileToSelect.occupiedBy.alignment\r\n      ) {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x - 1][y - 1],\r\n          markedBy: this.state.board[x][y].coordinatesNumerical,\r\n          potentialPath: true,\r\n          potentialKill: true\r\n        });\r\n      }\r\n\r\n      if (\r\n        this.checkBounds(x - 1, y + 1) &&\r\n        this.state.board[x - 1][y + 1].occupiedBy !== null &&\r\n        this.state.board[x - 1][y + 1].occupiedBy.alignment !==\r\n          tileToSelect.occupiedBy.alignment\r\n      ) {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x - 1][y + 1],\r\n          markedBy: this.state.board[x][y].coordinatesNumerical,\r\n          potentialPath: true,\r\n          potentialKill: true\r\n        });\r\n      }\r\n\r\n      this.updateBoard(tilesToHighlight);\r\n    } else if (tileToSelect.occupiedBy.alignment === \"black\") {\r\n      // Creates an empty array and checks based on the Unit's position what tiles to highlight, makes a conditional check with a helper\r\n      // function to see that the tiles are inside the board to prevent arrayOutOfBounds exception, the ones that pass the check\r\n      // are pushed into the array that is later merged into the state. Each highlighted tile receives the coordinates of the tile\r\n      // that highlighted it so later on it knows from where to remove the tile and override onto themselves.\r\n\r\n      // NOTE: THIS ARRAY SHOULD BE VALIDATED FOR BOUNDS BEFORE IT GOES INTO MAP\r\n      const tilesToHighlight = [];\r\n\r\n      // Check if this is the first turn (Initial movement) of the pawn, where it can move two tiles instead of one\r\n      if (x === 1) {\r\n        if (this.checkBounds(x + 2, y)) {\r\n          tilesToHighlight.push({\r\n            ...this.state.board[x + 2][y],\r\n            markedBy: this.state.board[x][y].coordinatesNumerical,\r\n            potentialPath: true\r\n          });\r\n        }\r\n      }\r\n      //\r\n\r\n      if (this.checkBounds(x + 1, y)) {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x + 1][y],\r\n          markedBy: this.state.board[x][y].coordinatesNumerical,\r\n          potentialPath: true\r\n        });\r\n      }\r\n\r\n      // This checks for potential kills of the unit, if the tile's not empty\r\n      if (\r\n        this.checkBounds(x + 1, y - 1) &&\r\n        this.state.board[x + 1][y - 1].occupiedBy !== null &&\r\n        this.state.board[x + 1][y - 1].occupiedBy.alignment !==\r\n          tileToSelect.occupiedBy.alignment\r\n      ) {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x + 1][y - 1],\r\n          markedBy: this.state.board[x][y].coordinatesNumerical,\r\n          potentialPath: true,\r\n          potentialKill: true\r\n        });\r\n      }\r\n\r\n      if (\r\n        this.checkBounds(x + 1, y + 1) &&\r\n        this.state.board[x + 1][y + 1].occupiedBy !== null &&\r\n        this.state.board[x + 1][y + 1].occupiedBy.alignment !==\r\n          tileToSelect.occupiedBy.alignment\r\n      ) {\r\n        tilesToHighlight.push({\r\n          ...this.state.board[x + 1][y + 1],\r\n          markedBy: this.state.board[x][y].coordinatesNumerical,\r\n          potentialPath: true,\r\n          potentialKill: true\r\n        });\r\n      }\r\n\r\n      this.updateBoard(tilesToHighlight);\r\n    }\r\n  };\r\n\r\n  // Gets an x and y index and checks if the tile is within the bounds of the board. Used to make sure that no tiles outside\r\n  // board bounds will be highlighted\r\n  checkBounds = (x, y) => {\r\n    if (x > 7 || x < 0 || y > 7 || y < 0) return false;\r\n    return true;\r\n  };\r\n\r\n  // Second major function that is responsible for the actual movement of the units and updating the appropriate data\r\n  // Takes a highlighted tile as an argument, moves the unit that marked it to that tile.\r\n  step = highlighted => {\r\n    // Extract x, y axis for readability\r\n    const x = highlighted.markedBy[0];\r\n    const y = highlighted.markedBy[1];\r\n    // Get the unit we want to move\r\n    const getUnit = { ...this.state.board[x][y].occupiedBy };\r\n\r\n    // These are Strings used for the creation of the history log array's entries (i.e player moved from x to y)\r\n    // which will later be passed to a child component for display\r\n    let from = ``,\r\n      to = ``,\r\n      kill = ``,\r\n      player = ``;\r\n\r\n    // Determines which player color goes into the string\r\n    this.state.blacksTurn === true ? (player = \"Black\") : (player = \"White\");\r\n\r\n    this.setState(({ board }) => ({\r\n      board: board.map((row, i) => {\r\n        let newRow = row.map((tile, j) => {\r\n          if (i === x && j === y) {\r\n            // Coords for building the turn entry string\r\n            from = `[(${tile.coordinates[0]}, ${tile.coordinates[1]})/(${\r\n              tile.coordinatesNumerical[0]\r\n            }, ${tile.coordinatesNumerical[1]})]`;\r\n            //\r\n            return { ...tile, occupiedBy: null };\r\n          } else if (\r\n            i === highlighted.coordinatesNumerical[0] &&\r\n            j === highlighted.coordinatesNumerical[1]\r\n          ) {\r\n            // Coords for building the turn entry string\r\n            to = `[(${tile.coordinates[0]}, ${tile.coordinates[1]})/(${\r\n              tile.coordinatesNumerical[0]\r\n            }, ${tile.coordinatesNumerical[1]})]`;\r\n            // This is working as intended but not optimal since React conventions discourage using nested setStates and prefers\r\n            // putting this inside componentDidUpdate or similar. Should refactor this when I come up with a more elegant solution.\r\n            if (tile.occupiedBy !== null) {\r\n              // Updates the defeated unit logs, checks whether win conditions have been met and returns a built kill entry for the\r\n              // turn history log\r\n              kill = this.updateStats(tile, kill);\r\n            }\r\n            //\r\n\r\n            // Update history log depending on whether a kill was made or not\r\n            if (kill === \"\") {\r\n              // If kill remained empty then turn was movement only, update with one entry\r\n              this.setState(curState => ({\r\n                history: [\r\n                  `${player} moved from ${from} to ${to}`,\r\n                  ...curState.history\r\n                ]\r\n              }));\r\n            } else {\r\n              // If kill was updated in updateStats function and is not an empty string, push two entries into the log\r\n              this.setState(curState => ({\r\n                history: [\r\n                  kill,\r\n                  `${player} moved from ${from} to ${to}`,\r\n                  ...curState.history\r\n                ]\r\n              }));\r\n            }\r\n            //\r\n\r\n            return { ...tile, occupiedBy: getUnit, potentialKill: false };\r\n          } else {\r\n            return tile;\r\n          }\r\n        });\r\n\r\n        // warning said wasn't returning in all cases, so I added this\r\n        return newRow;\r\n      })\r\n    }));\r\n\r\n    // Removes highlighting after movement is done\r\n    this.unSelect();\r\n\r\n    // End turn and switch active units\r\n    this.endTurn();\r\n  };\r\n  \r\n  // Main function that shows movement/kill options for every clicked unit\r\n  select = tileToSelect => {\r\n    // console.log(\"Selected Unit: \");\r\n    // console.log(tileToSelect.occupiedBy);\r\n\r\n    // If the tile has a unit in it, it can be selected\r\n    if (tileToSelect.occupiedBy !== null) {\r\n      // isActive determines the player's turn, so that both players don't move at the same time\r\n      if (tileToSelect.isActive === true) {\r\n        let name = tileToSelect.occupiedBy.name;\r\n\r\n        switch (name) {\r\n          case \"pawn\":\r\n            this.selectPawn(tileToSelect);\r\n            break;\r\n          case \"rook\":\r\n            this.selectRook(tileToSelect);\r\n            break;\r\n          case \"knight\":\r\n            this.selectKnight(tileToSelect);\r\n            break;\r\n          case \"bishop\":\r\n            this.selectBishop(tileToSelect);\r\n            break;\r\n          case \"queen\":\r\n            this.selectQueen(tileToSelect);\r\n            break;\r\n          case \"king\":\r\n            this.selectKing(tileToSelect);\r\n            break;\r\n\r\n          default:\r\n            console.log(\"ERR: Default case shouldn't be reachable\");\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  // Removes highlighting potential movement on right click\r\n  unSelect = () => {\r\n    // To update state need to map over the whole board\r\n    this.setState(({ board }) => ({\r\n      board: board.map((row, i) => {\r\n        let newRow = row.map((tile, j) => {\r\n          // Creates a temp object for the tile to reset the highlighting on turn\r\n          const tempObj = tile;\r\n          tempObj.potentialPath = false;\r\n          tempObj.markedBy = false;\r\n          tempObj.potentialKill = false;\r\n          return tempObj;\r\n        });\r\n        // warning said I wasn't returning in all cases, so I added this\r\n        return newRow;\r\n      })\r\n    }));\r\n  };\r\n\r\n  // Creates a unit on the board based on the provided coordinates. Used on board initialization only\r\n  createUnit = (x, y) => {\r\n    let name, alignment;\r\n\r\n    // Determines alignment\r\n    if (x === \"G\" || x === \"H\") alignment = \"white\";\r\n    else if (x === \"B\" || x === \"A\") alignment = \"black\";\r\n\r\n    // Determines unit\r\n    if ((x === \"A\" || x === \"H\") && (y === \"0\" || y === \"7\")) name = \"rook\";\r\n    if (x === \"B\" || x === \"G\") name = \"pawn\";\r\n    if ((x === \"H\" || x === \"A\") && (y === \"1\" || y === \"6\")) name = \"knight\";\r\n    if ((x === \"H\" || x === \"A\") && (y === \"2\" || y === \"5\")) name = \"bishop\";\r\n    if ((x === \"H\" || x === \"A\") && y === \"4\") name = \"queen\";\r\n    if ((x === \"H\" || x === \"A\") && y === \"3\") name = \"king\";\r\n\r\n    // If there's no alignment means there's no unit in that tile, returns null\r\n    if (alignment === undefined) return null;\r\n\r\n    // Otherwise, if there's an alignment assemble the Unit object and return it.\r\n    return {\r\n      name: name,\r\n      alignment: alignment,\r\n      coordinates: [x, y]\r\n    };\r\n  };\r\n\r\n  // Initialize board with default board values before rendering\r\n  // This function initializes the state\r\n  initBoard = () => {\r\n    for (let i = 0; i < 8; i++) {\r\n      // Switch statement to determine the tile's x axis coordinate in accordance to the array loop index.\r\n      // this will go into the tile obj later on\r\n      let TILE_X_AXIS;\r\n      switch (i) {\r\n        case (i = 0):\r\n          TILE_X_AXIS = \"A\";\r\n          break;\r\n        case (i = 1):\r\n          TILE_X_AXIS = \"B\";\r\n          break;\r\n        case (i = 2):\r\n          TILE_X_AXIS = \"C\";\r\n          break;\r\n        case (i = 3):\r\n          TILE_X_AXIS = \"D\";\r\n          break;\r\n        case (i = 4):\r\n          TILE_X_AXIS = \"E\";\r\n          break;\r\n        case (i = 5):\r\n          TILE_X_AXIS = \"F\";\r\n          break;\r\n        case (i = 6):\r\n          TILE_X_AXIS = \"G\";\r\n          break;\r\n        case (i = 7):\r\n          TILE_X_AXIS = \"H\";\r\n          break;\r\n\r\n        // Should never be reached\r\n        default:\r\n          TILE_X_AXIS = \"AXIS_X_DEFAULT\";\r\n      }\r\n\r\n      // Determines whether the first tile in the column is filled or not, flips in the end of every iteration\r\n      // of the inner loop\r\n      let firstTileInCol;\r\n      i % 2 === 0 ? (firstTileInCol = false) : (firstTileInCol = true);\r\n\r\n      // To later push into state to create a 2D array\r\n      const subArr = [];\r\n      for (let j = 0; j < 8; j++) {\r\n        // Inner loop creates the sub-array\r\n        // In chess boards the Y axis is numerical so the index of the loop is used\r\n        let TILE_Y_AXIS = `${j}`;\r\n\r\n        // Creates the individual tile object on the board\r\n        let tileObj = {\r\n          isFilled: firstTileInCol,\r\n          occupiedBy: this.createUnit(TILE_X_AXIS, TILE_Y_AXIS), // Will return null if no unit should be created at tile\r\n          coordinates: [TILE_X_AXIS, TILE_Y_AXIS],\r\n          coordinatesNumerical: [i, j],\r\n          // This will be used for flagging potential unit movement paths\r\n          potentialPath: false,\r\n          potentialKill: false,\r\n          // When potentialPath is flipped for movement paths, the sender unit's coordinatesNumerical field will be sent here\r\n          // for moving the piece\r\n          markedBy: null,\r\n          isActive: null\r\n        };\r\n\r\n        // Determine whether the tile is active or not at the start of the game. White always starts first\r\n        if (tileObj.occupiedBy !== null) {\r\n          if (tileObj.occupiedBy.alignment === \"white\") {\r\n            tileObj.isActive = true;\r\n          } else if (tileObj.occupiedBy.alignment === \"black\") {\r\n            tileObj.isActive = false;\r\n          }\r\n        }\r\n        //\r\n\r\n        subArr.push(tileObj);\r\n        firstTileInCol = !firstTileInCol;\r\n      }\r\n\r\n      this.setState(curState => ({\r\n        board: [...curState.board, subArr]\r\n      }));\r\n    }\r\n  };\r\n\r\n  // Calls init board\r\n  componentDidMount() {\r\n    this.initBoard();\r\n    this.setState({ blacksTurn: false });\r\n    this.setState({\r\n      history: [],\r\n      defeatedBlack: [],\r\n      defeatedWhite: [],\r\n      hasWon: null\r\n    });\r\n  }\r\n\r\n  // Maps over the state and renders the board\r\n  renderBoard = () => {\r\n    return (\r\n      <Zoom in={true} timeout={1500}>\r\n        <table className=\"board\">\r\n          <tbody>\r\n            {this.state.board.map(col => (\r\n              <tr key={uuid()}>\r\n                {col.map(tile => (\r\n                  // on click should go here\r\n                  <Tile\r\n                    key={uuid()}\r\n                    isFilled={tile.isFilled}\r\n                    select={this.select}\r\n                    unSelect={this.unSelect}\r\n                    step={this.step}\r\n                    tileState={tile}\r\n                  >\r\n                    {/* {tile.coordinates} */}\r\n                    {/* If the tile is not empty only then render a unit */}\r\n                    {tile.occupiedBy === null ? null : (\r\n                      <Unit\r\n                        name={tile.occupiedBy.name}\r\n                        alignment={tile.occupiedBy.alignment}\r\n                        onClick={this.move}\r\n                      />\r\n                    )}\r\n                  </Tile>\r\n                ))}\r\n              </tr>\r\n            ))}\r\n          </tbody>\r\n        </table>\r\n      </Zoom>\r\n    );\r\n  };\r\n\r\n  // Calls the renderBoard function to show board\r\n  render() {\r\n    let player = \"\";\r\n    this.state.blacksTurn === true ? (player = \"Black\") : (player = \"White\");\r\n\r\n    return (\r\n      <div>\r\n        <Grid\r\n          container\r\n          spacing={1}\r\n          className=\"grid\"\r\n          direction=\"row\"\r\n          justify=\"space-between\"\r\n        >\r\n          <Grid item xs={12} lg={3}>\r\n            <span>\r\n              <Defeated\r\n                white={this.state.defeatedWhite}\r\n                black={this.state.defeatedBlack}\r\n              />\r\n            </span>\r\n          </Grid>\r\n          <Grid item xs={12} lg={6}>\r\n            <span>\r\n              <Button\r\n                variant=\"outlined\"\r\n                color=\"default\"\r\n                className=\"button\"\r\n                onClick={this.newGame}\r\n              >\r\n                New Game\r\n              </Button>\r\n\r\n              {this.state.hasWon !== \"black\" &&\r\n              this.state.hasWon !== \"white\" ? (\r\n                this.renderBoard()\r\n              ) : (\r\n                <h1 className=\"gameover-msg\">\r\n                  {this.state.hasWon} won! Play again?\r\n                </h1>\r\n              )}\r\n            </span>\r\n          </Grid>\r\n          <Grid item xs={12} lg={3}>\r\n            <span>\r\n              <History history={this.state.history} player={player} />\r\n            </span>\r\n          </Grid>\r\n        </Grid>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Board;\r\n","import React from 'react';\r\nimport './App.css';\r\nimport Board from './components/Board'\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <Board />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}